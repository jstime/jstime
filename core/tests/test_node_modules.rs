use jstime_core as jstime;
use std::fs;
use std::path::Path;

mod common;

/// Helper to create a directory structure
fn create_dir_all(path: &Path) {
    fs::create_dir_all(path).expect("Failed to create directory");
}

/// Helper to write a file
fn write_file(path: &Path, content: &str) {
    fs::write(path, content).expect("Failed to write file");
}

/// Helper to clean up test directory
fn cleanup(path: &Path) {
    let _ = fs::remove_dir_all(path);
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test importing a simple package from node_modules with "main" field
    #[test]
    fn test_node_modules_simple_main() {
        let _setup_guard = common::setup();

        // Create test directory structure
        let temp_dir = std::env::temp_dir().join("jstime_test_simple_main");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create node_modules/test-pkg with package.json and main entry
        let pkg_dir = temp_dir.join("node_modules").join("test-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "test-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const message = "Hello from test-pkg!";"#,
        );

        // Create test file that imports from node_modules
        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { message } from 'test-pkg';
globalThis.testResult = message;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.testResult", "test");
        assert_eq!(result.unwrap(), "Hello from test-pkg!");

        cleanup(&temp_dir);
    }

    /// Test importing a package with exports field
    #[test]
    fn test_node_modules_exports_field() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_exports");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("exports-pkg");
        create_dir_all(&pkg_dir.join("dist"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "exports-pkg", "exports": { ".": "./dist/index.js" }}"#,
        );

        write_file(
            &pkg_dir.join("dist").join("index.js"),
            r#"export const version = "1.0.0";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { version } from 'exports-pkg';
globalThis.pkgVersion = version;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.pkgVersion", "test");
        assert_eq!(result.unwrap(), "1.0.0");

        cleanup(&temp_dir);
    }

    /// Test importing a scoped package (@scope/package)
    #[test]
    fn test_node_modules_scoped_package() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_scoped");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir
            .join("node_modules")
            .join("@test-scope")
            .join("test-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "@test-scope/test-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const scopedMessage = "Hello from scoped package!";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { scopedMessage } from '@test-scope/test-pkg';
globalThis.scopedResult = scopedMessage;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.scopedResult", "test");
        assert_eq!(result.unwrap(), "Hello from scoped package!");

        cleanup(&temp_dir);
    }

    /// Test importing a subpath from a package
    #[test]
    fn test_node_modules_subpath() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_subpath");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("subpath-pkg");
        create_dir_all(&pkg_dir.join("lib"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "subpath-pkg", "main": "index.js"}"#,
        );

        write_file(&pkg_dir.join("index.js"), r#"export const main = "main";"#);

        write_file(
            &pkg_dir.join("lib").join("utils.js"),
            r#"export const helper = "helper function";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { helper } from 'subpath-pkg/lib/utils.js';
globalThis.subpathResult = helper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.subpathResult", "test");
        assert_eq!(result.unwrap(), "helper function");

        cleanup(&temp_dir);
    }

    /// Test walking up directory tree to find node_modules
    #[test]
    fn test_node_modules_parent_directory() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_parent");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create node_modules at root level
        let pkg_dir = temp_dir.join("node_modules").join("parent-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "parent-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const found = "Found in parent!";"#,
        );

        // Create nested directory for test file
        let nested_dir = temp_dir.join("src").join("lib").join("deep");
        create_dir_all(&nested_dir);

        let test_file = nested_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { found } from 'parent-pkg';
globalThis.parentResult = found;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.parentResult", "test");
        assert_eq!(result.unwrap(), "Found in parent!");

        cleanup(&temp_dir);
    }

    /// Test that relative imports still work with node_modules resolution
    #[test]
    fn test_relative_import_still_works() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_relative");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        write_file(
            &temp_dir.join("helper.js"),
            r#"export const helper = "from relative import";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { helper } from './helper.js';
globalThis.relativeResult = helper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.relativeResult", "test");
        assert_eq!(result.unwrap(), "from relative import");

        cleanup(&temp_dir);
    }

    /// Test dynamic import with bare specifier
    #[test]
    fn test_dynamic_import_bare_specifier() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_dynamic_bare");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("dynamic-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "dynamic-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const dynamicExport = "loaded dynamically";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
const mod = await import('dynamic-pkg');
globalThis.dynamicResult = mod.dynamicExport;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.dynamicResult", "test");
        assert_eq!(result.unwrap(), "loaded dynamically");

        cleanup(&temp_dir);
    }

    /// Test error when package is not found
    #[test]
    fn test_node_modules_not_found() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_not_found");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { something } from 'nonexistent-package';
globalThis.result = something;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(
            result.is_err(),
            "Should have failed to import nonexistent package"
        );

        cleanup(&temp_dir);
    }

    /// Test package with index.js fallback when no main field
    #[test]
    fn test_node_modules_index_fallback() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_index_fallback");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("index-pkg");
        create_dir_all(&pkg_dir);

        // Package.json without main field
        write_file(&pkg_dir.join("package.json"), r#"{"name": "index-pkg"}"#);

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const indexDefault = "from index.js";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { indexDefault } from 'index-pkg';
globalThis.indexResult = indexDefault;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.indexResult", "test");
        assert_eq!(result.unwrap(), "from index.js");

        cleanup(&temp_dir);
    }

    /// Test package with string exports (not object)
    #[test]
    fn test_node_modules_exports_string() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_exports_string");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("string-exports-pkg");
        create_dir_all(&pkg_dir.join("lib"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "string-exports-pkg", "exports": "./lib/main.js"}"#,
        );

        write_file(
            &pkg_dir.join("lib").join("main.js"),
            r#"export const stringExport = "from string exports";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { stringExport } from 'string-exports-pkg';
globalThis.stringExportResult = stringExport;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.stringExportResult", "test");
        assert_eq!(result.unwrap(), "from string exports");

        cleanup(&temp_dir);
    }

    /// Test transitive dependencies
    #[test]
    fn test_node_modules_transitive() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_transitive");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create pkg-a which depends on pkg-b
        let pkg_a_dir = temp_dir.join("node_modules").join("pkg-a");
        create_dir_all(&pkg_a_dir);

        write_file(
            &pkg_a_dir.join("package.json"),
            r#"{"name": "pkg-a", "main": "index.js"}"#,
        );

        write_file(
            &pkg_a_dir.join("index.js"),
            r#"
import { bValue } from 'pkg-b';
export const aValue = "a:" + bValue;
            "#,
        );

        // Create pkg-b
        let pkg_b_dir = temp_dir.join("node_modules").join("pkg-b");
        create_dir_all(&pkg_b_dir);

        write_file(
            &pkg_b_dir.join("package.json"),
            r#"{"name": "pkg-b", "main": "index.js"}"#,
        );

        write_file(&pkg_b_dir.join("index.js"), r#"export const bValue = "b";"#);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { aValue } from 'pkg-a';
globalThis.transitiveResult = aValue;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.transitiveResult", "test");
        assert_eq!(result.unwrap(), "a:b");

        cleanup(&temp_dir);
    }

    /// Test conditional exports with "import" key
    #[test]
    fn test_node_modules_conditional_exports() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_conditional");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("conditional-pkg");
        create_dir_all(&pkg_dir.join("esm"));
        create_dir_all(&pkg_dir.join("cjs"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{
  "name": "conditional-pkg",
  "exports": {
    ".": {
      "import": "./esm/index.js",
      "require": "./cjs/index.js"
    }
  }
}"#,
        );

        write_file(
            &pkg_dir.join("esm").join("index.js"),
            r#"export const moduleType = "ESM";"#,
        );

        write_file(
            &pkg_dir.join("cjs").join("index.js"),
            r#"module.exports = { moduleType: "CJS" };"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { moduleType } from 'conditional-pkg';
globalThis.conditionalResult = moduleType;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.conditionalResult", "test");
        assert_eq!(result.unwrap(), "ESM");

        cleanup(&temp_dir);
    }

    /// Test that node: prefix still works
    #[test]
    fn test_node_prefix_still_works() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_node_prefix");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import fs from 'node:fs/promises';
globalThis.hasReadFile = typeof fs.readFile === 'function';
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.hasReadFile", "test");
        assert_eq!(result.unwrap(), "true");

        cleanup(&temp_dir);
    }
}
