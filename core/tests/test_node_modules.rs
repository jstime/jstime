use jstime_core as jstime;
use std::fs;
use std::path::Path;

mod common;

/// Helper to create a directory structure
fn create_dir_all(path: &Path) {
    fs::create_dir_all(path).expect("Failed to create directory");
}

/// Helper to write a file
fn write_file(path: &Path, content: &str) {
    fs::write(path, content).expect("Failed to write file");
}

/// Helper to clean up test directory
fn cleanup(path: &Path) {
    let _ = fs::remove_dir_all(path);
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test importing a simple package from node_modules with "main" field
    #[test]
    fn test_node_modules_simple_main() {
        let _setup_guard = common::setup();

        // Create test directory structure
        let temp_dir = std::env::temp_dir().join("jstime_test_simple_main");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create node_modules/test-pkg with package.json and main entry
        let pkg_dir = temp_dir.join("node_modules").join("test-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "test-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const message = "Hello from test-pkg!";"#,
        );

        // Create test file that imports from node_modules
        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { message } from 'test-pkg';
globalThis.testResult = message;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.testResult", "test");
        assert_eq!(result.unwrap(), "Hello from test-pkg!");

        cleanup(&temp_dir);
    }

    /// Test importing a package with exports field
    #[test]
    fn test_node_modules_exports_field() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_exports");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("exports-pkg");
        create_dir_all(&pkg_dir.join("dist"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "exports-pkg", "exports": { ".": "./dist/index.js" }}"#,
        );

        write_file(
            &pkg_dir.join("dist").join("index.js"),
            r#"export const version = "1.0.0";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { version } from 'exports-pkg';
globalThis.pkgVersion = version;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.pkgVersion", "test");
        assert_eq!(result.unwrap(), "1.0.0");

        cleanup(&temp_dir);
    }

    /// Test importing a scoped package (@scope/package)
    #[test]
    fn test_node_modules_scoped_package() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_scoped");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir
            .join("node_modules")
            .join("@test-scope")
            .join("test-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "@test-scope/test-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const scopedMessage = "Hello from scoped package!";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { scopedMessage } from '@test-scope/test-pkg';
globalThis.scopedResult = scopedMessage;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.scopedResult", "test");
        assert_eq!(result.unwrap(), "Hello from scoped package!");

        cleanup(&temp_dir);
    }

    /// Test importing a subpath from a package
    #[test]
    fn test_node_modules_subpath() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_subpath");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("subpath-pkg");
        create_dir_all(&pkg_dir.join("lib"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "subpath-pkg", "main": "index.js"}"#,
        );

        write_file(&pkg_dir.join("index.js"), r#"export const main = "main";"#);

        write_file(
            &pkg_dir.join("lib").join("utils.js"),
            r#"export const helper = "helper function";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { helper } from 'subpath-pkg/lib/utils.js';
globalThis.subpathResult = helper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.subpathResult", "test");
        assert_eq!(result.unwrap(), "helper function");

        cleanup(&temp_dir);
    }

    /// Test walking up directory tree to find node_modules
    #[test]
    fn test_node_modules_parent_directory() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_parent");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create node_modules at root level
        let pkg_dir = temp_dir.join("node_modules").join("parent-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "parent-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const found = "Found in parent!";"#,
        );

        // Create nested directory for test file
        let nested_dir = temp_dir.join("src").join("lib").join("deep");
        create_dir_all(&nested_dir);

        let test_file = nested_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { found } from 'parent-pkg';
globalThis.parentResult = found;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.parentResult", "test");
        assert_eq!(result.unwrap(), "Found in parent!");

        cleanup(&temp_dir);
    }

    /// Test that relative imports still work with node_modules resolution
    #[test]
    fn test_relative_import_still_works() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_relative");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        write_file(
            &temp_dir.join("helper.js"),
            r#"export const helper = "from relative import";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { helper } from './helper.js';
globalThis.relativeResult = helper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.relativeResult", "test");
        assert_eq!(result.unwrap(), "from relative import");

        cleanup(&temp_dir);
    }

    /// Test dynamic import with bare specifier
    #[test]
    fn test_dynamic_import_bare_specifier() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_dynamic_bare");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("dynamic-pkg");
        create_dir_all(&pkg_dir);

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "dynamic-pkg", "main": "index.js"}"#,
        );

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const dynamicExport = "loaded dynamically";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
const mod = await import('dynamic-pkg');
globalThis.dynamicResult = mod.dynamicExport;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.dynamicResult", "test");
        assert_eq!(result.unwrap(), "loaded dynamically");

        cleanup(&temp_dir);
    }

    /// Test error when package is not found
    #[test]
    fn test_node_modules_not_found() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_not_found");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { something } from 'nonexistent-package';
globalThis.result = something;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(
            result.is_err(),
            "Should have failed to import nonexistent package"
        );

        cleanup(&temp_dir);
    }

    /// Test package with index.js fallback when no main field
    #[test]
    fn test_node_modules_index_fallback() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_index_fallback");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("index-pkg");
        create_dir_all(&pkg_dir);

        // Package.json without main field
        write_file(&pkg_dir.join("package.json"), r#"{"name": "index-pkg"}"#);

        write_file(
            &pkg_dir.join("index.js"),
            r#"export const indexDefault = "from index.js";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { indexDefault } from 'index-pkg';
globalThis.indexResult = indexDefault;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.indexResult", "test");
        assert_eq!(result.unwrap(), "from index.js");

        cleanup(&temp_dir);
    }

    /// Test package with string exports (not object)
    #[test]
    fn test_node_modules_exports_string() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_exports_string");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("string-exports-pkg");
        create_dir_all(&pkg_dir.join("lib"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{"name": "string-exports-pkg", "exports": "./lib/main.js"}"#,
        );

        write_file(
            &pkg_dir.join("lib").join("main.js"),
            r#"export const stringExport = "from string exports";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { stringExport } from 'string-exports-pkg';
globalThis.stringExportResult = stringExport;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.stringExportResult", "test");
        assert_eq!(result.unwrap(), "from string exports");

        cleanup(&temp_dir);
    }

    /// Test transitive dependencies
    #[test]
    fn test_node_modules_transitive() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_transitive");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        // Create pkg-a which depends on pkg-b
        let pkg_a_dir = temp_dir.join("node_modules").join("pkg-a");
        create_dir_all(&pkg_a_dir);

        write_file(
            &pkg_a_dir.join("package.json"),
            r#"{"name": "pkg-a", "main": "index.js"}"#,
        );

        write_file(
            &pkg_a_dir.join("index.js"),
            r#"
import { bValue } from 'pkg-b';
export const aValue = "a:" + bValue;
            "#,
        );

        // Create pkg-b
        let pkg_b_dir = temp_dir.join("node_modules").join("pkg-b");
        create_dir_all(&pkg_b_dir);

        write_file(
            &pkg_b_dir.join("package.json"),
            r#"{"name": "pkg-b", "main": "index.js"}"#,
        );

        write_file(&pkg_b_dir.join("index.js"), r#"export const bValue = "b";"#);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { aValue } from 'pkg-a';
globalThis.transitiveResult = aValue;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.transitiveResult", "test");
        assert_eq!(result.unwrap(), "a:b");

        cleanup(&temp_dir);
    }

    /// Test conditional exports with "import" key
    #[test]
    fn test_node_modules_conditional_exports() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_conditional");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let pkg_dir = temp_dir.join("node_modules").join("conditional-pkg");
        create_dir_all(&pkg_dir.join("esm"));
        create_dir_all(&pkg_dir.join("cjs"));

        write_file(
            &pkg_dir.join("package.json"),
            r#"{
  "name": "conditional-pkg",
  "exports": {
    ".": {
      "import": "./esm/index.js",
      "require": "./cjs/index.js"
    }
  }
}"#,
        );

        write_file(
            &pkg_dir.join("esm").join("index.js"),
            r#"export const moduleType = "ESM";"#,
        );

        write_file(
            &pkg_dir.join("cjs").join("index.js"),
            r#"module.exports = { moduleType: "CJS" };"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { moduleType } from 'conditional-pkg';
globalThis.conditionalResult = moduleType;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.conditionalResult", "test");
        assert_eq!(result.unwrap(), "ESM");

        cleanup(&temp_dir);
    }

    /// Test that node: prefix still works
    #[test]
    fn test_node_prefix_still_works() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_node_prefix");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import fs from 'node:fs/promises';
globalThis.hasReadFile = typeof fs.readFile === 'function';
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.hasReadFile", "test");
        assert_eq!(result.unwrap(), "true");

        cleanup(&temp_dir);
    }

    /// Test package imports with exact match (#utils)
    #[test]
    fn test_package_imports_exact_match() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_imports_exact");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src"));

        // Create package.json with imports field
        write_file(
            &temp_dir.join("package.json"),
            r##"{
  "name": "my-app",
  "imports": {
    "#utils": "./src/utils.js"
  }
}"##,
        );

        write_file(
            &temp_dir.join("src").join("utils.js"),
            r##"export const helper = "Hello from #utils!";"##,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r##"
import { helper } from '#utils';
globalThis.importsResult = helper;
            "##,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.importsResult", "test");
        assert_eq!(result.unwrap(), "Hello from #utils!");

        cleanup(&temp_dir);
    }

    /// Test package imports with wildcard pattern (#internal/*)
    #[test]
    fn test_package_imports_wildcard() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_imports_wildcard");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src").join("internal"));

        // Create package.json with wildcard imports
        // Using concat to avoid Rust raw string issues with /*
        let package_json = concat!(
            "{\n",
            "  \"name\": \"my-app\",\n",
            "  \"imports\": {\n",
            "    \"#internal/",
            "*\": \"./src/internal/",
            "*.js\"\n",
            "  }\n",
            "}"
        );
        write_file(&temp_dir.join("package.json"), package_json);

        write_file(
            &temp_dir.join("src").join("internal").join("helpers.js"),
            r#"export const internalHelper = "From internal helpers!";"#,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r#"
import { internalHelper } from '#internal/helpers';
globalThis.wildcardResult = internalHelper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.wildcardResult", "test");
        assert_eq!(result.unwrap(), "From internal helpers!");

        cleanup(&temp_dir);
    }

    /// Test package imports with conditional exports
    #[test]
    fn test_package_imports_conditional() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_imports_conditional");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src").join("esm"));
        create_dir_all(&temp_dir.join("src").join("cjs"));

        // Create package.json with conditional imports
        write_file(
            &temp_dir.join("package.json"),
            r##"{
  "name": "my-app",
  "imports": {
    "#config": {
      "import": "./src/esm/config.js",
      "require": "./src/cjs/config.js"
    }
  }
}"##,
        );

        write_file(
            &temp_dir.join("src").join("esm").join("config.js"),
            r##"export const configType = "ESM config";"##,
        );

        write_file(
            &temp_dir.join("src").join("cjs").join("config.js"),
            r##"module.exports = { configType: "CJS config" };"##,
        );

        let test_file = temp_dir.join("test.js");
        write_file(
            &test_file,
            r##"
import { configType } from '#config';
globalThis.conditionalImportResult = configType;
            "##,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.conditionalImportResult", "test");
        assert_eq!(result.unwrap(), "ESM config");

        cleanup(&temp_dir);
    }

    /// Test package imports in nested directory
    #[test]
    fn test_package_imports_nested_directory() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_imports_nested");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src").join("lib").join("deep"));

        // Create package.json at root with imports field
        write_file(
            &temp_dir.join("package.json"),
            r##"{
  "name": "my-app",
  "imports": {
    "#shared": "./src/shared.js"
  }
}"##,
        );

        write_file(
            &temp_dir.join("src").join("shared.js"),
            r##"export const sharedValue = "Shared from root!";"##,
        );

        // Test file is deeply nested
        let test_file = temp_dir
            .join("src")
            .join("lib")
            .join("deep")
            .join("test.js");
        write_file(
            &test_file,
            r##"
import { sharedValue } from '#shared';
globalThis.nestedImportResult = sharedValue;
            "##,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.nestedImportResult", "test");
        assert_eq!(result.unwrap(), "Shared from root!");

        cleanup(&temp_dir);
    }

    /// Test self-referencing import (package imports itself by its own name)
    #[test]
    fn test_self_reference_import_main() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_self_ref");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src"));

        // Create package.json with name and exports
        write_file(
            &temp_dir.join("package.json"),
            r#"{
  "name": "my-library",
  "exports": {
    ".": "./src/index.js",
    "./utils": "./src/utils.js"
  }
}"#,
        );

        write_file(
            &temp_dir.join("src").join("index.js"),
            r#"export const main = "Hello from main!";"#,
        );

        write_file(
            &temp_dir.join("src").join("utils.js"),
            r#"export const helper = "Hello from utils!";"#,
        );

        // Test file that imports from its own package using the package name
        let test_file = temp_dir.join("src").join("test.js");
        write_file(
            &test_file,
            r#"
import { main } from 'my-library';
globalThis.selfRefResult = main;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.selfRefResult", "test");
        assert_eq!(result.unwrap(), "Hello from main!");

        cleanup(&temp_dir);
    }

    /// Test self-referencing import with subpath (package imports a subpath of itself)
    #[test]
    fn test_self_reference_import_subpath() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_self_ref_sub");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src"));

        // Create package.json with name and exports
        write_file(
            &temp_dir.join("package.json"),
            r#"{
  "name": "my-library",
  "exports": {
    ".": "./src/index.js",
    "./utils": "./src/utils.js"
  }
}"#,
        );

        write_file(
            &temp_dir.join("src").join("index.js"),
            r#"export const main = "Hello from main!";"#,
        );

        write_file(
            &temp_dir.join("src").join("utils.js"),
            r#"export const helper = "Hello from utils!";"#,
        );

        // Test file that imports a subpath from its own package using the package name
        let test_file = temp_dir.join("src").join("test.js");
        write_file(
            &test_file,
            r#"
import { helper } from 'my-library/utils';
globalThis.selfRefSubpathResult = helper;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.selfRefSubpathResult", "test");
        assert_eq!(result.unwrap(), "Hello from utils!");

        cleanup(&temp_dir);
    }

    /// Test self-referencing import from nested directory
    #[test]
    fn test_self_reference_import_nested() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_self_ref_nested");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src").join("lib").join("deep"));

        // Create package.json with name and exports at root
        write_file(
            &temp_dir.join("package.json"),
            r#"{
  "name": "my-library",
  "exports": "./src/index.js"
}"#,
        );

        write_file(
            &temp_dir.join("src").join("index.js"),
            r#"export const value = "From the root!";"#,
        );

        // Test file is deeply nested
        let test_file = temp_dir
            .join("src")
            .join("lib")
            .join("deep")
            .join("test.js");
        write_file(
            &test_file,
            r#"
import { value } from 'my-library';
globalThis.nestedSelfRefResult = value;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.nestedSelfRefResult", "test");
        assert_eq!(result.unwrap(), "From the root!");

        cleanup(&temp_dir);
    }

    /// Test self-referencing import with scoped package name
    #[test]
    fn test_self_reference_scoped_package() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_self_ref_scoped");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src"));

        // Create package.json with scoped name and exports
        write_file(
            &temp_dir.join("package.json"),
            r#"{
  "name": "@myorg/my-library",
  "exports": {
    ".": "./src/index.js"
  }
}"#,
        );

        write_file(
            &temp_dir.join("src").join("index.js"),
            r#"export const scopedMain = "Hello from scoped package!";"#,
        );

        // Test file that imports from its own scoped package
        let test_file = temp_dir.join("src").join("test.js");
        write_file(
            &test_file,
            r#"
import { scopedMain } from '@myorg/my-library';
globalThis.scopedSelfRefResult = scopedMain;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.scopedSelfRefResult", "test");
        assert_eq!(result.unwrap(), "Hello from scoped package!");

        cleanup(&temp_dir);
    }

    /// Test self-referencing import with conditional exports
    #[test]
    fn test_self_reference_conditional_exports() {
        let _setup_guard = common::setup();

        let temp_dir = std::env::temp_dir().join("jstime_test_self_ref_cond");
        cleanup(&temp_dir);
        create_dir_all(&temp_dir);
        create_dir_all(&temp_dir.join("src").join("esm"));

        // Create package.json with conditional exports
        write_file(
            &temp_dir.join("package.json"),
            r#"{
  "name": "my-library",
  "exports": {
    ".": {
      "import": "./src/esm/index.js",
      "default": "./src/esm/index.js"
    }
  }
}"#,
        );

        write_file(
            &temp_dir.join("src").join("esm").join("index.js"),
            r#"export const moduleType = "ESM version";"#,
        );

        // Test file that imports from its own package
        let test_file = temp_dir.join("src").join("test.js");
        write_file(
            &test_file,
            r#"
import { moduleType } from 'my-library';
globalThis.conditionalSelfRefResult = moduleType;
            "#,
        );

        let options = jstime::Options::default();
        let mut jstime = jstime::JSTime::new(options);

        let result = jstime.import(test_file.to_str().unwrap());
        assert!(result.is_ok(), "Failed to import: {:?}", result);

        let result = jstime.run_script("globalThis.conditionalSelfRefResult", "test");
        assert_eq!(result.unwrap(), "ESM version");

        cleanup(&temp_dir);
    }
}
